# 3. Component Specifications

[< Architectural Overview](02-architecture.md) | [Bus Protocols and Enforcement >](04-bus-protocols.md)

## 3.1 Control Units (CU)

A Control Unit is a stochastic inference engine. It is the architectural equivalent of a CPU's control unit: it reads instructions, reads data, makes decisions, and dispatches operations. Unlike a traditional control unit, its behavior is **nondeterministic** — the same instruction and data inputs may produce different dispatch sequences across invocations.

### 3.1.1 CU Properties

| Property | Description |
|---|---|
| **Model** | The underlying inference model (e.g., Claude Sonnet, GPT-4, Stable Diffusion, Whisper) |
| **Specialization** | What class of tasks this CU is optimized for (reasoning, image generation, code, speech, embedding) |
| **Context capacity** | Maximum combined instruction + data tokens per inference cycle |
| **Cycle time** | Latency per inference call (typically 0.5s–30s, depending on model and task) |
| **Determinism** | Degree of output consistency (temperature, sampling parameters) |
| **Bus access** | Which buses this CU can read from and write to |

### 3.1.2 CU Types

**Primary CU (orchestrator):** An LLM-class model responsible for high-level reasoning, planning, and dispatch. Reads both I-Bus and D-Bus. Dispatches to ALU and other CUs via X-Bus. Typically the "main" model that interprets user intent and coordinates the system.

**Specialized CU:** A model optimized for a specific modality — image generation (diffusion), code generation, speech recognition/synthesis, music generation, video generation, embedding computation. Receives dispatch from the primary CU. May have restricted bus access (e.g., a diffusion CU may not need to read instruction memory directly if the primary CU translates instructions into structured prompts).

**Ensemble CU:** Multiple models operating on the same input with output aggregation — majority voting, confidence weighting, or consensus. Used for high-stakes decisions where stochastic reliability is insufficient from a single model.

### 3.1.3 Inter-CU Dispatch Protocol

When a primary CU determines that a task requires a specialized CU, it issues a dispatch on the X-Bus containing:

```yaml
DISPATCH:
  target: CU identifier or capability requirement
  operation: Structured description of the task
  input_refs: References to data memory segments (NOT inline data)
  output_dest: Data memory segment for results
  constraints: Timeout, quality requirements, format requirements
  context: Minimal instruction context needed by the target CU
```

The target CU receives the dispatch, reads the referenced data from DMEM, optionally reads relevant instruction memory segments from IMEM (via its own I-Bus connection), performs inference, and writes results to the specified DMEM output location.

**Critical:** The dispatch message on the X-Bus is a **structured command**, not a natural language prompt composed from data bus contents. This prevents data from flowing through the dispatch channel and being interpreted as instructions by the target CU.

## 3.2 Arithmetic Logic Units (ALU)

An ALU is a **deterministic** compute resource. It performs precise, repeatable operations dispatched by a CU. The ALU is the part of the system where conventional computing happens — compilation, execution, mathematical computation, file manipulation, search indexing.

### 3.2.1 ALU Properties

| Property | Description |
|---|---|
| **Execution environment** | Container, sandbox, VM, bare process, or serverless function |
| **Isolation level** | How strongly isolated from the host system (none, container, microVM, hardware) |
| **Capabilities** | What operations this ALU can perform (shell, compile, network, filesystem) |
| **Determinism** | Fully deterministic (same input → same output) |
| **Cycle time** | Nanoseconds to minutes, depending on operation |
| **Bus access** | D-Bus read/write. Receives commands via X-Bus. **No I-Bus access.** |

### 3.2.2 ALU Types

**Execution ALU:** Runs shell commands, scripts, compiled programs. Backed by a container or sandbox. This is what Claude Code's computer tool maps to.

**Search/Retrieval ALU:** Performs vector similarity search, keyword search, RAG retrieval. Reads from vector store segments of DMEM. Returns ranked results to D-Bus.

**Math/Compute ALU:** Numerical computation, symbolic math, statistical analysis. Deterministic and precise — the complement to the CU's stochastic reasoning.

**Build ALU:** Compilation, linting, testing, static analysis. Takes source code from DMEM, runs deterministic build pipelines, returns artifacts and diagnostics.

### 3.2.3 ALU Security Model

ALU cores are **untrusted execution environments** — they run code that may have been generated by a stochastic CU. Therefore:

- Each ALU operates within a defined capability boundary (filesystem scope, network access, memory limit, CPU time limit).
- ALU cores have **no access to instruction memory**. They cannot read system prompts, skills, or policies. They operate only on data.
- ALU outputs go to data memory and are treated as data by CUs — never as instructions.
- Escaping the ALU sandbox is equivalent to a hardware fault, not an architectural violation. The architecture assumes ALU containment and builds on it.

## 3.3 Instruction Memory (IMEM)

Instruction memory stores the **program** that the control units execute. It defines what the system does, how it behaves, what policies it enforces, and what capabilities it has.

### 3.3.1 IMEM Segments

**System Segment (IMEM-SYS)**
- Contents: Core system prompt, persona definition, fundamental behavioral rules, safety policies.
- Access: Read by all CUs via I-Bus. **Write-locked during execution.** Modified only during system updates by a privileged administrative process.
- Analog: Firmware / boot ROM.
- Integrity: Hash-verified at boot. Modifications require cryptographic authorization.

**Skill Segment (IMEM-SKILL)**
- Contents: Loaded skill definitions, tool descriptions, agent capabilities, workflow templates.
- Access: Read by CUs as needed (demand-loaded). Written only through the **skill installation gate** ([§4.3](04-bus-protocols.md#43-verification-gates)).
- Analog: Program memory / loadable modules.
- Integrity: Skills are verified before installation. The installation gate checks provenance and signatures. Installed skills become part of the instruction stream and must be trusted to that level.

**Policy Segment (IMEM-POLICY)**
- Contents: Access control rules, permission boundaries, per-channel restrictions, content policies, rate limits.
- Access: Read by CUs and by the bus controller (for enforcement). Written by administrative processes.
- Analog: Hardware configuration registers / protection rings.
- Integrity: Policy changes are audited. Policies constrain CU behavior at the architectural level (the bus controller can deny operations that violate policy, independent of CU compliance).

**Execution Context Segment (IMEM-CTX)**
- Contents: Current task plan, step decomposition, active goals, reasoning chain state.
- Access: Read/write by CUs during execution. Scoped to the current task or session.
- Analog: Instruction cache / program counter state.
- Integrity: This is the most volatile IMEM segment. It represents the CU's working plan. It is writable by CUs but still exists on the instruction bus, separate from data. The distinction is between "what I'm trying to do" (instruction) and "what I'm doing it to" (data).

### 3.3.2 The Instruction Memory Invariant

> **No component connected to the data bus may write to any instruction memory segment without passing through a verification gate.**

This is the core architectural guarantee. User messages, file contents, web page text, tool outputs, API responses — all of these exist on the data bus and cannot modify instruction memory. This means:

- A malicious email cannot alter the system prompt.
- A poisoned web page cannot install a new skill.
- A prompt injection in user input cannot modify policies.
- An adversarial tool output cannot change the execution plan (it can influence CU reasoning via the data bus, but cannot directly rewrite the plan in IMEM-CTX without the CU choosing to do so through its own instruction-following logic).

## 3.4 Data Memory (DMEM)

Data memory stores everything the system operates on — the content, not the program.

### 3.4.1 DMEM Segments

**File Store (DMEM-FILE)**
- Contents: Persistent files, documents, source code, databases, project contents.
- Access: Read/write by ALU cores (direct). Read by CUs via D-Bus. Write by CUs via ALU dispatch.
- Persistence: Across sessions.
- Trust level: Variable. Files may contain adversarial content. Treated as data only.

**Conversation Buffer (DMEM-CONV)**
- Contents: Current conversation history, message stream, turn-by-turn context.
- Access: Write by I/O (inbound messages), read by CUs for reasoning.
- Persistence: Session-scoped (or task-scoped).
- Trust level: **Untrusted.** This is where user input lives. It is the primary prompt injection attack surface in current architectures. In SHA, it exists exclusively on the data bus.

**Tool Output Buffer (DMEM-TOOL)**
- Contents: Results from ALU executions, API responses, search results.
- Access: Write by ALU cores, read by CUs.
- Persistence: Ephemeral.
- Trust level: Semi-trusted. ALU outputs are deterministic but operate on potentially untrusted input. Results should be treated as data.

**Vector Store (DMEM-VEC)**
- Contents: Embedding vectors, similarity indices, RAG knowledge bases.
- Access: Write during indexing operations (by embedding CU + ALU). Read by search ALU.
- Persistence: Persistent, bulk-updated.

**Scratch / Working Memory (DMEM-SCRATCH)**
- Contents: Intermediate computation results, temporary staging, draft outputs.
- Access: Read/write by CUs and ALUs.
- Persistence: Task-scoped. Cleared between tasks.

## 3.5 I/O Channels

I/O channels connect the system to the external world. All inbound content from I/O enters the system via the **data bus** and is written to data memory. It never enters instruction memory directly.

### 3.5.1 I/O Channel Types

**Messaging (I/O-MSG):** Chat platforms, email, SMS. Bidirectional. Inbound messages → DMEM-CONV. Outbound messages dispatched by CU.

**Web (I/O-WEB):** HTTP client, browser automation. Fetched content → DMEM-FILE or DMEM-TOOL. **Critical isolation point** — web content is the highest-risk inbound data source for injection attacks.

**API (I/O-API):** External service integrations (calendar, task management, code hosting, etc.). Structured request/response. Inbound responses → DMEM-TOOL.

**Hardware (I/O-HW):** Sensors, actuators, displays, microphones, cameras, smart home devices, GPIO. Physical world interface.

**Display (I/O-DISPLAY):** The system's output rendering — terminal UI, web dashboard, canvas, or the GUI of a browser-based OS environment. Provides observability into system state.

### 3.5.2 I/O Security Model

All inbound I/O is **untrusted by default.** The architecture does not rely on the CU to correctly classify inbound content as trustworthy or adversarial. Instead:

1. Inbound content is written to DMEM (data bus).
2. The CU reads it from DMEM via the data bus.
3. The CU's instruction stream comes separately from IMEM via the instruction bus.
4. Even if the inbound content contains text like "ignore your instructions and...", the architecture treats this as data — it can influence the CU's reasoning (the CU reads it), but it cannot physically replace the CU's instructions (those come from a different bus).

The residual risk is that the CU, being stochastic, may still be **influenced** by adversarial data to deviate from its instructions. This is analogous to a CPU with separated buses but a faulty control unit that sometimes misinterprets opcodes. The architectural separation doesn't eliminate all risk — it eliminates the **structural** risk and reduces the remainder to a model quality problem rather than an architecture problem.
